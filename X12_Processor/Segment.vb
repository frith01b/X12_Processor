Option Strict On
Option Explicit On

Imports System.Xml
Imports System.Data
Imports System.IO
Imports System.Xml.Serialization
Imports X12_Processor
Imports System.Text

' @TODO  Sub-field processing
' @TODO  Load_Field_Config() (XML)
' SegTranslate: interface is used to allow accessing detail object record references (ISA, GS, etc) generically.
Public Interface SegTranslate
    ' Recordname: used to identify proper processing method and object hierarchy
    Property RecordName As String
    'RecordLength: overall import length of data for validation checking
    Property RecordLength As Integer
    Property FieldDefs As FieldDefSet
    Property FieldCount As Integer
    Property FieldDefFile As String
    ' Fields contain actual input data
    Property Fields As Dictionary(Of String, String)
    Property LoopData As List(Of SegTranslate)
    Property Parent As SegTranslate
    'RecIndex used for actual data records to maintain order of input/output
    Property RecIndex As Long
    Sub InitializeTranDef()
    Sub Import(Seg As ParseSegment, SourceRecNum As Long)
    Sub ReMap()
    Sub LoadFieldDef()
    Sub SaveTranDef()
    Sub AddLoopItem(MySegment As SegTranslate)

    ' Filter removes extraneous notes/data
    Function Filter() As String()
    Function Gen_FixedLength_Record(ByRef MyTrans As Segment) As String
    Function GetData() As Segment
    'Output_X12:Remap adjusts incoming data to correct item #'s, code values , etc
    Function Output_X12() As String
    Function Validate() As Boolean
    Function Gen_X12_Record(InRec As Segment) As String



End Interface


<Serializable()>
Public Class Segment
    Implements SegTranslate

    Dim _RecordName As String
    Dim _RecordLength As Integer
    Dim _FieldDefs As FieldDefSet
    Dim _FieldCount As Integer
    Dim _FieldDefFile As String
    Dim _RecIndex As Long
    Dim _LoopData As List(Of SegTranslate)
    Dim _Parent As SegTranslate

    Private _Fields As Dictionary(Of String, String)
    Public Sub New(RecType As String)
        _Fields = New Dictionary(Of String, String)
        _RecordName = RecType
        If _FieldCount = 0 Then
            '@TODO  need reference to other versions
            'Field names are sorted , And Import() / output Is generated by alpha order of fields) 
            _FieldDefFile = ConfigInfo.SegmentDefDir & "\" & _RecordName & ".def"
            LoadFieldDef(ConfigInfo.SegmentDefDir & "\" & _RecordName & ".def")
        End If
    End Sub
    Public Sub New()
        If _FieldCount = 0 Then
            ' @TODO  need reference to other versions
            'Field names are sorted , and import/output is generated by alpha order of fields) 
            _FieldDefFile = ConfigInfo.SegmentDefDir & "\" & _RecordName & ".def"
            LoadFieldDef(ConfigInfo.SegmentDefDir & "\" & _RecordName & ".def")
        End If
    End Sub
    Public Property Fields As Dictionary(Of String, String) Implements SegTranslate.Fields
        Get
            Return _Fields
        End Get
        Set(value As Dictionary(Of String, String))
            _Fields = _Fields.Union(value).ToDictionary(Function(d) d.Key, Function(d) d.Value)
        End Set

    End Property

    Public Property RecordName As String Implements SegTranslate.RecordName
        Get
            Return _RecordName
        End Get
        Set(value As String)
            _RecordName = value
        End Set
    End Property

    Public Property RecordLength As Integer Implements SegTranslate.RecordLength
        Get
            Return _RecordLength
        End Get
        Set(value As Integer)
            _RecordLength = value
        End Set
    End Property

    Public Property FieldDefs As FieldDefSet Implements SegTranslate.FieldDefs
        Get
            Return _FieldDefs
        End Get
        Set(value As FieldDefSet)
            _FieldDefs = value
        End Set
    End Property

    Public Property FieldCount As Integer Implements SegTranslate.FieldCount
        Get
            Return _FieldCount
        End Get
        Set(value As Integer)
            _FieldCount = value
        End Set
    End Property

    Public Property FieldDefFile As String Implements SegTranslate.FieldDefFile
        Get
            Return _FieldDefFile
        End Get
        Set(value As String)
            _FieldDefFile = value
        End Set
    End Property

    Public Property RecIndex As Long Implements SegTranslate.RecIndex
        Get
            Return _RecIndex
        End Get
        Set(value As Long)
            _RecIndex = value
        End Set
    End Property

    Public Property LoopData As List(Of SegTranslate) Implements SegTranslate.LoopData
        Get
            If _LoopData Is Nothing Then
                _LoopData = New List(Of SegTranslate)
            End If
            Return _LoopData

        End Get
        Set(value As List(Of SegTranslate))
            _LoopData = value
        End Set
    End Property

    Public Property Parent As SegTranslate Implements SegTranslate.Parent
        Get
            Return _Parent
        End Get
        Set(value As SegTranslate)
            _Parent = value
        End Set
    End Property

    Public Sub Remove_Field_Key(Value As String)
        _Fields.Remove(Value)
    End Sub
    Public Sub Set_Field_Key(NewKey As String, NewValue As String)
        _Fields(NewKey) = NewValue
    End Sub
    Public Function Get_Field_Key(NewKey As String) As String
        Return _Fields(NewKey)
    End Function

    Sub AddFieldDef(NewField As FieldDef)
        If NewField.FName.Length > 0 Then
            FieldCount = FieldCount + 1
            FieldDefs.FieldDefList.Add(NewField)
        Else
            Interchange.AddError("ERR002:Unable to create Field ", Interchange.Error_Type_List.StdError)
        End If
    End Sub
    Sub RemoveFieldDef(FieldName As String)
        FieldDefs.FieldDefList.RemoveAll(Function(field) field.FName = FieldName)
    End Sub


    Public Sub Import(Seg As ParseSegment, SourceRecNum As Long) Implements SegTranslate.Import
        Interchange.RecordCount = Interchange.RecordCount + 1
        Try
            ' use incoming field count instead of default map
            'because not all fields always populated
            For x = 0 To Seg.Elements.Count - 1
                Set_Field_Key(FieldDefs.FieldDefList(x).FName, Seg.Elements(x).Trim)
            Next
        Catch ex As Exception
            Interchange.AddError("ERR001:Unable to parse " & Seg.SegID & " to " & _RecordName & " segment at Source File Rec#" & SourceRecNum, Interchange.Error_Type_List.StdError)
        End Try


    End Sub

    Public Function GetData() As Segment Implements SegTranslate.GetData
        Return Me
    End Function

    Public Function Output_X12() As String Implements SegTranslate.Output_X12
        Dim RESULT As StringBuilder = New StringBuilder
        Dim FieldList As List(Of String)
        Dim x As Integer

        RESULT.Append(String.Join("", Enumerable.Repeat(" ", RecordLength)))

        FieldList = _Fields.Keys.ToList()
        FieldList.Sort()

        ' add record name
        RESULT.Append(RecordName & Interchange.FieldDelimiter)


        For x = 0 To FieldList.Count - 1
            'need to substring & PAD & Strip quotes

            Select Case FieldDefs.FieldDefList(x).Alignment.ToUpper
                Case "LPAD"
                    ' should be getfield that calls these as subs
                    RESULT.Append(Get_Field_LPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding))
                Case "RPAD"
                    RESULT.Append(Get_Field_RPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding))
                Case "ZPAD"
                    RESULT.Append(Get_Field_ZPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding))
                Case "RAW"
                    RESULT.Append(_Fields(FieldList(x)))
                Case "NONE"
                    RESULT.Append(_Fields(FieldList(x)))
                Case Else
                    RESULT.Append(_Fields(FieldList(x)))

            End Select

            If x = FieldList.Count - 1 Then
                'If PartnerInfo.X12_Always_Delimiter = True Or Mid(PartnerInfo.M2K_PARTNER_ID, 1, 5) = "PRIDE" Or Mid(PartnerInfo.M2K_PARTNER_ID, 1, 5) = "CLARK" Then
                '    RESULT.append(X12SegDelimiter
                'end if
            Else
                RESULT.Append(Interchange.FieldDelimiter)
            End If

        Next

        Return RESULT.ToString
    End Function

    Public Function Filter() As String() Implements SegTranslate.Filter
        Debug.Print("not yet implemented")
    End Function

    Public Sub ReMap() Implements SegTranslate.ReMap
        Debug.Print("not yet implemented")
    End Sub

    ' fixed length field output
    Function Get_Field_RPAD(outField As String, myLen As Integer, myPad As String) As String

        ' ensure data does not contain field/element delimiter
        outField = outField.Replace(Interchange.FieldDelimiter, Interchange.FieldDelimiter_Replace_Char)
        ' add padding character to end, limit max size to myLen
        outField &= String.Join("", Enumerable.Repeat(myPad, myLen))
        outField = outField.Substring(1, myLen) & Interchange.FieldDelimiter
        Return outField
    End Function
    Function Get_Field_LPAD(ByRef outField As String, myLen As Integer, myPad As String) As String
        ' ensure data does not contain field/element delimiter
        If outField <> Nothing Then
            outField = outField.Replace(Interchange.FieldDelimiter, Interchange.FieldDelimiter_Replace_Char)
        Else
            outField = ""
        End If
        ' add padding character to beginning, limit max size to myLen
        outField = String.Join("", Enumerable.Repeat(myPad, myLen)) & outField
        outField = outField.Substring(myLen) & Interchange.FieldDelimiter
        Return (outField)

    End Function
    Function Get_Field_ZPAD(ByRef outField As String, myLen As Integer, myPad As String) As String
        ' add zero padding character to beginning, limit max size to myLen
        outField = outField.Replace(Interchange.FieldDelimiter, Interchange.FieldDelimiter_Replace_Char)
        outField = String.Join("", Enumerable.Repeat("0", myLen)) & outField
        outField = Right(outField, myLen) & Interchange.FieldDelimiter
        Return (outField)

    End Function

    Function Right(myStr As String, size As Integer) As String
        Dim result As String = ""

        If size >= myStr.Length Then
            myStr.Substring(myStr.Length - size, size)
        Else
            result = myStr
        End If
        Return result

    End Function

    Public Function Gen_FixedLength_Record(ByRef MyTrans As Segment) As String Implements SegTranslate.Gen_FixedLength_Record
        Dim FieldList As List(Of String)
        Dim x As Integer
        Dim Result As String

        Result = String.Join("", Enumerable.Repeat(" ", RecordLength))

        FieldList = _Fields.Keys.ToList()
        FieldList.Sort()
        For x = 0 To FieldList.Count - 1
            'need to substring & PAD & Strip quotes
            If FieldDefs.FieldDefList(x).FLength > 1 Then

                Select Case FieldDefs.FieldDefList(x).Alignment
                    Case "LPAD"
                        Result = Result.Substring(1, FieldDefs.FieldDefList(x).StartPosition - 1) & Get_Field_LPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding) & Result.Substring(FieldDefs.FieldDefList(x).StartPosition + FieldDefs.FieldDefList(x).FLength + 1)

                    Case "RPAD"
                        Result = Result.Substring(1, FieldDefs.FieldDefList(x).StartPosition - 1) & Get_Field_RPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding) & Result.Substring(FieldDefs.FieldDefList(x).StartPosition + FieldDefs.FieldDefList(x).FLength + 1)

                    Case "ZPAD"
                        Result = Result.Substring(1, FieldDefs.FieldDefList(x).StartPosition - 1) & Get_Field_ZPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding) & Result.Substring(FieldDefs.FieldDefList(x).StartPosition + FieldDefs.FieldDefList(x).FLength + 1)
                End Select
            Else
                Select Case FieldDefs.FieldDefList(x).Alignment
                    Case "LPAD"
                        Result = Get_Field_LPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding) & Result.Substring(FieldDefs.FieldDefList(x).StartPosition + FieldDefs.FieldDefList(x).FLength + 1)

                    Case "RPAD"
                        Result = Get_Field_RPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding) & Result.Substring(FieldDefs.FieldDefList(x).StartPosition + FieldDefs.FieldDefList(x).FLength + 1)

                    Case "ZPAD"
                        Result = Get_Field_ZPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding) & Result.Substring(FieldDefs.FieldDefList(x).StartPosition + FieldDefs.FieldDefList(x).FLength + 1)
                End Select
            End If
        Next

        Return Result
    End Function
    ''' <summary>
    ''' 
    ''' </summary>
    ''' <param name="InRec"></param>
    ''' <returns></returns>
    Public Function Gen_X12_Record(InRec As Segment) As String Implements SegTranslate.Gen_X12_Record
        Dim FieldCount As Integer
        Dim FieldList As List(Of String)
        Dim x As Integer
        Dim Result As StringBuilder = New StringBuilder

        FieldList = _Fields.Keys.ToList()
        FieldList.Sort()

        FieldCount = FieldList.Count

        For x = 0 To FieldCount - 1
            'need to substring & PAD & Strip quotes
            Select Case FieldDefs.FieldDefList(x).Alignment
                Case "LPAD"
                    Result.Append(Get_Field_LPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding))

                Case "RPAD"
                    Result.Append(Get_Field_RPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding))
                Case "ZPAD"
                    Result.Append(Get_Field_ZPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding))
            End Select

            If x < FieldCount - 1 Then
                Result.Append(Interchange.FieldDelimiter)
            End If
        Next
        Return Result.ToString
    End Function

    Public Function Validate() As Boolean Implements SegTranslate.Validate
        Debug.Print("not yet implemented")
    End Function
    Public Sub LoadFieldDef() Implements SegTranslate.LoadFieldDef
        LoadFieldDef(ConfigInfo.SegmentDefDir & "\" & _RecordName & ".def")
    End Sub
    Public Sub LoadFieldDef(TranDefFileName As String)
        If File.Exists(TranDefFileName) Then
            Dim xml_serializer As New XmlSerializer(GetType(FieldDefSet))
            Dim stream_reader As New StreamReader(TranDefFileName)
            Dim myFieldDefs As FieldDefSet
            myFieldDefs = DirectCast(xml_serializer.Deserialize(stream_reader),
                                                 FieldDefSet)
            stream_reader.Close()
        Else
            Interchange.AddError("ERR005:Missing TranDefFile : " & TranDefFileName, Interchange.Error_Type_List.StdError)
        End If
    End Sub

    Public Sub InitializeTranDef() Implements SegTranslate.InitializeTranDef
        Debug.Print("not yet implemented")
    End Sub

    Public Sub SaveTranDef() Implements SegTranslate.SaveTranDef
        ' remember  [gettype]()  for current object
        Dim writer As New System.Xml.Serialization.XmlSerializer([GetType]())
        Dim file As New System.IO.StreamWriter(path:=_FieldDefFile)
        writer.Serialize(file, Me)
        file.Close()
    End Sub

    Public Sub AddLoopItem(MySegment As SegTranslate) Implements SegTranslate.AddLoopItem
        If MySegment IsNot Nothing Then
            If _LoopData Is Nothing Then
                _LoopData = New List(Of SegTranslate)
            End If
            _LoopData.Add(MySegment)
        Else
            Interchange.AddError("ERR002:Null Segment add attempt ", Interchange.Error_Type_List.StdError)
        End If
    End Sub


    ' Public Function serializeObject(obj As Object) As Dictionary(Of String, String)
    'Dim dict As New Dictionary(Of String, String)
    'Dim properties As New ArrayList

    'For Each prop As FieldInfo In obj.GetType.GetFields
    '    properties.Add(prop)
    'Next

    'For Each prop In properties
    'Try
    '        dict.Add(prop.Name, prop.getValue(obj).ToString)
    '    Catch ex As Exception
    '        Console.WriteLine(ex.StackTrace)
    '    End Try
    'Next

    'Return dict

    'End Function

End Class
