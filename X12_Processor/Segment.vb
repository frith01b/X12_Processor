Option Strict On
Option Explicit On

Imports System.Xml
Imports System.Data
Imports System.IO
Imports System.Xml.Serialization
Imports X12_Processor

' @TODO  Sub-field processing
' @TODO  Load_Field_Config() (XML)

Interface SegTranslate
    Property RecordName As String
    Property RecordLength As Integer
    Property FieldDefs As FieldDefSet
    Property FieldCount As Integer
    Property FieldDefFile As String
    Property Fields As Dictionary(Of String, String)
    Sub InitializeTranDef()
    Sub Import(Seg As ParseSegment, SourceRecNum As Long)
    Sub ReMap()
    Sub LoadFieldDef()
    Sub SaveTranDef()


    ' Filter removes extraneous notes/data
    Function Filter() As String()
    Function Gen_FixedLength_Record(ByRef MyTrans As Segment) As String
    Function GetData() As Segment
    'Remap adjusts incoming data to correct item #'s, code values , etc
    Function Output_X12() As String
    Function Validate() As Boolean
    Function Gen_X12_Record(InRec As Segment) As String

End Interface


<Serializable()>
Public Class Segment
    Implements SegTranslate

    Dim _RecordName As String
    Dim _RecordLength As Integer
    Dim _FieldDefs As FieldDefSet
    Dim _FieldCount As Integer
    Dim _FieldDefFile As String

    Private _Fields As Dictionary(Of String, String)
    Public Sub New(RecType As String)
        _Fields = New Dictionary(Of String, String)
        _RecordName = RecType
        If _FieldCount = 0 Then
            ' @TODO  need reference to other versions
            'Field names are sorted , and import/output is generated by alpha order of fields) 
            _FieldDefFile = ConfigInfo.SegmentDefDir & "\" & _RecordName & ".def"
            LoadFieldDef(ConfigInfo.SegmentDefDir & "\" & _RecordName & ".def")
        End If
    End Sub
    Public Sub New()
        If _FieldCount = 0 Then
            ' @TODO  need reference to other versions
            'Field names are sorted , and import/output is generated by alpha order of fields) 
            _FieldDefFile = ConfigInfo.SegmentDefDir & "\" & _RecordName & ".def"
            LoadFieldDef(ConfigInfo.SegmentDefDir & "\" & _RecordName & ".def")
        End If
    End Sub
    Public Property Fields As Dictionary(Of String, String) Implements SegTranslate.Fields
        Get
            Return _Fields
        End Get
        Set(value As Dictionary(Of String, String))
            _Fields = _Fields.Union(value).ToDictionary(Function(d) d.Key, Function(d) d.Value)
        End Set

    End Property

    Public Property RecordName As String Implements SegTranslate.RecordName
        Get
            Return _RecordName
        End Get
        Set(value As String)
            _RecordName = value
        End Set
    End Property

    Public Property RecordLength As Integer Implements SegTranslate.RecordLength
        Get
            Return _RecordLength
        End Get
        Set(value As Integer)
            _RecordLength = value
        End Set
    End Property

    Public Property FieldDefs As FieldDefSet Implements SegTranslate.FieldDefs
        Get
            Return _FieldDefs
        End Get
        Set(value As FieldDefSet)
            _FieldDefs = value
        End Set
    End Property

    Public Property FieldCount As Integer Implements SegTranslate.FieldCount
        Get
            Return _FieldCount
        End Get
        Set(value As Integer)
            _FieldCount = value
        End Set
    End Property

    Public Property FieldDefFile As String Implements SegTranslate.FieldDefFile
        Get
            Return _FieldDefFile
        End Get
        Set(value As String)
            _FieldDefFile = value
        End Set
    End Property

    Public Sub Remove_Field_Key(Value As String)
        _Fields.Remove(Value)
    End Sub
    Public Sub Set_Field_Key(NewKey As String, NewValue As String)
        _Fields(NewKey) = NewValue
    End Sub
    Public Function Get_Field_Key(NewKey As String) As String
        Return _Fields(NewKey)
    End Function

    Sub AddFieldDef(NewField As FieldDef)
        If NewField.FName.Length > 0 Then
            FieldCount = FieldCount + 1
            FieldDefs.FieldDefList.Add(NewField)
        Else
            Interchange.AddError("ERR002:Unable to create Field ", Interchange.Error_Type_List.StdError)

        End If
    End Sub
    Sub RemoveFieldDef(FieldName As String)
        FieldDefs.FieldDefList.RemoveAll(Function(field) field.FName = FieldName)
    End Sub


    Public Sub Import(Seg As ParseSegment, SourceRecNum As Long) Implements SegTranslate.Import
        Interchange.RecordCount = Interchange.RecordCount + 1
        Try
            ' use incoming field count instead of default map
            'because not all fields always populated
            For x = 0 To Seg.Elements.Count - 1
                Set_Field_Key(FieldDefs.FieldDefList(x).FName, Seg.Elements(x).Trim)
            Next
        Catch ex As Exception
            Interchange.AddError("ERR001:Unable to parse " & Seg.SegID & " to " & _RecordName & " segment at Source File Rec#" & SourceRecNum, Interchange.Error_Type_List.StdError)
        End Try


    End Sub

    Public Function GetData() As Segment Implements SegTranslate.GetData
        Return Me
    End Function

    Public Function Output_X12() As String Implements SegTranslate.Output_X12
        Dim RESULT As String = ""
        Dim FieldList As List(Of String)
        Dim x As Integer

        RESULT = String.Join("", Enumerable.Repeat(" ", RecordLength))

        FieldList = _Fields.Keys.ToList()
        FieldList.Sort()



        For x = 0 To FieldList.Count - 1
            'need to substring & PAD & Strip quotes

            Select Case FieldDefs.FieldDefList(x).Alignment
                Case "LPAD"
                    ' should be getfield that calls these as subs
                    RESULT = RESULT & Get_Field_LPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding)
                Case "RPAD"
                    RESULT = RESULT & Get_Field_RPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding)
                Case "ZPAD"
                    RESULT = RESULT & Get_Field_ZPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding)
                Case "RAW"
                    RESULT = RESULT & _Fields(FieldList(x))
            End Select

            If x = FieldList.Count - 1 Then
                'If PartnerInfo.X12_Always_Delimiter = True Or Mid(PartnerInfo.M2K_PARTNER_ID, 1, 5) = "PRIDE" Or Mid(PartnerInfo.M2K_PARTNER_ID, 1, 5) = "CLARK" Then
                '    RESULT = RESULT & X12SegDelimiter
                'end if
            Else
                RESULT = RESULT & Interchange.FieldDelimiter
            End If

        Next

        Return RESULT
    End Function

    Public Function Filter() As String() Implements SegTranslate.Filter
        Throw New NotImplementedException()
    End Function

    Public Sub ReMap() Implements SegTranslate.ReMap
        Throw New NotImplementedException()
    End Sub

    ' fixed length field output
    Function Get_Field_RPAD(outField As String, myLen As Integer, myPad As String) As String

        ' ensure data does not contain field/element delimiter
        outField = outField.Replace(Interchange.FieldDelimiter, Interchange.FieldDelimiter_Replace_Char)
        ' add padding character to end, limit max size to myLen
        outField &= String.Join("", Enumerable.Repeat(myPad, myLen))
        outField = outField.Substring(1, myLen) + Interchange.FieldDelimiter
        Return outField
    End Function
    Function Get_Field_LPAD(ByRef outField As String, myLen As Integer, myPad As String) As String
        ' add padding character to beginning, limit max size to myLen
        outField = outField.Replace(Interchange.FieldDelimiter, Interchange.FieldDelimiter_Replace_Char)
        outField = String.Join("", Enumerable.Repeat(myPad, myLen)) & outField
        outField = Right(outField, myLen) & Interchange.FieldDelimiter
        Return (outField)

    End Function
    Function Get_Field_ZPAD(ByRef outField As String, myLen As Integer, myPad As String) As String
        ' add zero padding character to beginning, limit max size to myLen
        outField = outField.Replace(Interchange.FieldDelimiter, Interchange.FieldDelimiter_Replace_Char)
        outField = String.Join("", Enumerable.Repeat("0", myLen)) & outField
        outField = Right(outField, myLen) & Interchange.FieldDelimiter
        Return (outField)

    End Function

    Function Right(myStr As String, size As Integer) As String
        Dim result As String = ""

        If size >= myStr.Length Then
            myStr.Substring(myStr.Length - size, size)
        Else
            result = myStr
        End If
        Return result

    End Function

    Public Function Gen_FixedLength_Record(ByRef MyTrans As Segment) As String Implements SegTranslate.Gen_FixedLength_Record
        Dim FieldList As List(Of String)
        Dim x As Integer
        Dim Result As String

        Result = String.Join("", Enumerable.Repeat(" ", RecordLength))

        FieldList = _Fields.Keys.ToList()
        FieldList.Sort()



        For x = 0 To FieldList.Count - 1
            'need to substring & PAD & Strip quotes
            If FieldDefs.FieldDefList(x).FLength > 1 Then

                Select Case FieldDefs.FieldDefList(x).Alignment
                    Case "LPAD"

                        Result = Result.Substring(1, FieldDefs.FieldDefList(x).StartPosition - 1) & Get_Field_LPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding) & Result.Substring(FieldDefs.FieldDefList(x).StartPosition + FieldDefs.FieldDefList(x).FLength + 1)
                    Case "RPAD"
                        Result = Result.Substring(1, FieldDefs.FieldDefList(x).StartPosition - 1) & Get_Field_RPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding) & Result.Substring(FieldDefs.FieldDefList(x).StartPosition + FieldDefs.FieldDefList(x).FLength + 1)
                    Case "ZPAD"
                        Result = Result.Substring(1, FieldDefs.FieldDefList(x).StartPosition - 1) & Get_Field_ZPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding) & Result.Substring(FieldDefs.FieldDefList(x).StartPosition + FieldDefs.FieldDefList(x).FLength + 1)
                End Select
            Else
                Select Case FieldDefs.FieldDefList(x).Alignment
                    Case "LPAD"

                        Result = Get_Field_LPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding) & Result.Substring(FieldDefs.FieldDefList(x).StartPosition + FieldDefs.FieldDefList(x).FLength + 1)
                    Case "RPAD"
                        Result = Get_Field_RPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding) & Result.Substring(FieldDefs.FieldDefList(x).StartPosition + FieldDefs.FieldDefList(x).FLength + 1)
                    Case "ZPAD"
                        Result = Get_Field_ZPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding) & Result.Substring(FieldDefs.FieldDefList(x).StartPosition + FieldDefs.FieldDefList(x).FLength + 1)
                End Select
            End If
        Next

        Return Result
    End Function
    Public Function Gen_X12_Record(InRec As Segment) As String Implements SegTranslate.Gen_X12_Record
        Dim FieldCount As Integer
        Dim FieldList As List(Of String)
        Dim x As Integer
        Dim Result As String = ""

        FieldList = _Fields.Keys.ToList()
        FieldList.Sort()

        FieldCount = FieldList.Count

        For x = 0 To FieldCount - 1
            'need to substring & PAD & Strip quotes
            Select Case FieldDefs.FieldDefList(x).Alignment
                Case "LPAD"
                    Result &= Get_Field_LPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding)
                Case "RPAD"
                    Result &= Get_Field_RPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding)
                Case "ZPAD"
                    Result &= Get_Field_ZPAD(_Fields(FieldList(x)), FieldDefs.FieldDefList(x).FLength, FieldDefs.FieldDefList(x).Padding)
            End Select

            If x < FieldCount - 1 Then
                Result &= Interchange.FieldDelimiter
            End If
        Next
        Return Result
    End Function

    Public Function Validate() As Boolean Implements SegTranslate.Validate
        Throw New NotImplementedException()
    End Function
    Public Sub LoadFieldDef() Implements SegTranslate.LoadFieldDef
        LoadFieldDef(ConfigInfo.SegmentDefDir & "\" & _RecordName & ".def")
    End Sub
    Public Sub LoadFieldDef(TranDefFileName As String)
        If File.Exists(TranDefFileName) Then
            Dim xml_serializer As New XmlSerializer(GetType(FieldDefSet))
            Dim stream_reader As New StreamReader(TranDefFileName)
            Dim myFieldDefs As FieldDefSet = DirectCast(xml_serializer.Deserialize(stream_reader),
                                                 FieldDefSet)
            stream_reader.Close()
        Else

        End If
    End Sub

    Public Sub InitializeTranDef() Implements SegTranslate.InitializeTranDef
        Throw New NotImplementedException()
    End Sub

    Public Sub SaveTranDef() Implements SegTranslate.SaveTranDef
        ' remember  [gettype]()  for current object
        Dim writer As New System.Xml.Serialization.XmlSerializer([GetType]())
        Dim file As New System.IO.StreamWriter(path:=_FieldDefFile)
        writer.Serialize(file, Me)
        file.Close()
    End Sub

    ' Public Function serializeObject(obj As Object) As Dictionary(Of String, String)
    'Dim dict As New Dictionary(Of String, String)
    'Dim properties As New ArrayList

    'For Each prop As FieldInfo In obj.GetType.GetFields
    '    properties.Add(prop)
    'Next

    'For Each prop In properties
    'Try
    '        dict.Add(prop.Name, prop.getValue(obj).ToString)
    '    Catch ex As Exception
    '        Console.WriteLine(ex.StackTrace)
    '    End Try
    'Next

    'Return dict

    'End Function

End Class
